# Image Corruption Classifier

A PyTorch-based Convolutional Neural Network (CNN) to identify common types of image corruptions like noise, blur, and compression artifacts. This project serves as a clear, self-contained example of creating a custom dataset, defining a model, and implementing a full training and evaluation pipeline in a Jupyter Notebook.



*(Image represents the kind of output generated by the project's prediction visualization)*

## Features

-   **Multi-Class Classification**: Classifies images into four categories:
    1.  Clean (Original)
    2.  Gaussian Noise
    3.  Gaussian Blur
    4.  JPEG Compression Artifacts (simulated)
-   **Dynamic Corruption**: Implements a custom PyTorch `Dataset` that dynamically applies corruptions to the base CIFAR-10 dataset, creating a balanced and augmented training set on the fly.
-   **Simple & Effective CNN**: Utilizes a straightforward yet effective CNN architecture suitable for image classification tasks.
-   **Complete Workflow**: Includes the entire machine learning pipeline: data loading, model definition, training, evaluation, and prediction visualization.
-   **Reproducible**: All code is contained within a single Jupyter Notebook (`.ipynb`) with a fixed random seed for reproducible results.

## Technologies Used

-   **Language**: Python 3
-   **Core Libraries**:
    -   [PyTorch](https://pytorch.org/): For building and training the neural network.
    -   [Torchvision](https://pytorch.org/vision/stable/index.html): For the CIFAR-10 dataset and image transforms.
    -   [Pillow (PIL)](https://python-pillow.org/): For applying image filtering and corruption effects.
    -   [Matplotlib](https://matplotlib.org/): For visualizing data samples and prediction results.
    -   [Jupyter Notebook](https://jupyter.org/): For interactive development and presentation.

## Installation

To get this project up and running on your local machine, follow these steps. A virtual environment is highly recommended.

1.  **Clone the repository:**
    ```bash
    git clone https://github.com/your-username/image-corruption-classifier.git
    cd image-corruption-classifier
    ```

2.  **Create and activate a virtual environment (optional but recommended):**
    ```bash
    python -m venv venv
    # On Windows
    venv\Scripts\activate
    # On macOS/Linux
    source venv/bin/activate
    ```

3.  **Install the required dependencies:**
    A `requirements.txt` file should be created with the following content:
    ```txt
    torch
    torchvision
    Pillow
    matplotlib
    jupyter
    ```
    Then, install them using pip:
    ```bash
    pip install -r requirements.txt
    ```

## Usage

The entire project is contained within the `ImageCorruptionClassifier.ipynb` notebook.

1.  **Launch Jupyter Notebook:**
    From your terminal in the project's root directory, run:
    ```bash
    jupyter notebook
    ```

2.  **Open and Run the Notebook:**
    -   In the Jupyter interface that opens in your browser, click on `ImageCorruptionClassifier.ipynb`.
    -   You can run all cells sequentially by selecting `Cell > Run All` from the menu bar.
    -   The CIFAR-10 dataset will be automatically downloaded to a `./data` directory on the first run.

3.  **Expected Output:**
    -   The notebook will print the training progress for each epoch, showing the training/validation loss and accuracy.
    -   After training is complete, the final cell will generate and display a plot of sample test images, annotating each with its **T**rue corruption label and the model's **P**redicted label.

## Configuration

Key hyperparameters and settings can be easily modified in the second code cell of the notebook ("Basic config").

| Parameter       | Description                                                               | Default Value |
| --------------- | ------------------------------------------------------------------------- | ------------- |
| `SEED`          | The random seed for reproducibility.                                      | `42`          |
| `DATA_ROOT`     | The directory where the CIFAR-10 dataset will be stored.                  | `"./data"`    |
| `BATCH_SIZE`    | The number of samples per batch during training and testing.              | `128`         |
| `EPOCHS`        | The total number of training epochs.                                      | `5`           |
| `LEARNING_RATE` | The learning rate for the Adam optimizer.                                 | `1e-3`        |

Additionally, the intensity of each corruption can be adjusted within the corruption functions in the third code cell:
-   `add_gaussian_noise(img, std)`
-   `add_blur(img, radius)`
-   `add_jpeg_compression(img, downscale_factor)`

## Project Structure

The project has a very simple structure, designed for clarity and ease of use.

```
image-corruption-classifier/
│
├── ImageCorruptionClassifier.ipynb   # The main Jupyter Notebook containing all code.
├── requirements.txt                  # List of Python dependencies.
├── README.md                         # This file.
└── data/                             # (Created automatically) Stores the CIFAR-10 dataset.
```

### Notebook Organization

The notebook is organized into logical sections:

1.  **Imports**: All necessary libraries are imported.
2.  **Basic Config**: Central location for all key hyperparameters.
3.  **Corruption Functions**: Functions to apply specific corruptions to images.
4.  **Corrupted CIFAR-10 Dataset**: The custom `torch.utils.data.Dataset` class definition.
5.  **Data Loading & Visualization**: Creating `DataLoader` instances and previewing the augmented data.
6.  **Model Definition**: The `SimpleCNN` PyTorch model architecture.
7.  **Training**: The main training and evaluation loop.
8.  **Prediction**: A function to run inference on test samples and visualize the results.

## Contributing

Contributions are welcome! If you have suggestions for improvements or find any issues, please feel free to:

1.  **Fork** the repository.
2.  Create a new **branch** (`git checkout -b feature/your-feature-name`).
3.  **Commit** your changes (`git commit -am 'Add some feature'`).
4.  **Push** to the branch (`git push origin feature/your-feature-name`).
5.  Open a **Pull Request**.

You can also open an issue with the "bug" or "enhancement" tag.